<!--
    INDEX.HTML LOADS WASM AND THE CONTENT GET OVERWRITTEN BY WASM.

    IF USER IS ON AN UNSUPPORTED WEB BROWSER AND COULD NOT LOAD WASM
    THIS PAGE WOULD BE LOADED FOR THEM AND NO OVERWRITING CONTENT.
--><!DOCTYPE html><html><head>
        <link rel="stylesheet" href="index.css">
        <meta charset="utf-8">
        <title>URCL-rs</title>
    
<link rel="preload" href="/urcl-rs-807a995c3564dcc7_bg.wasm" as="fetch" type="application/wasm" crossorigin="">
<link rel="modulepreload" href="/urcl-rs-807a995c3564dcc7.js"></head>
    <body>
        <h2>Loading WASM</h2>
        <h3>Cannot load?</h3>
        <p>
            Check if your browser supports WASM or if you have to enable it in your browser's experimental flags.
        </p>
    
<script type="module">import init from '/urcl-rs-807a995c3564dcc7.js';init('/urcl-rs-807a995c3564dcc7_bg.wasm');</script><script>(function () {
    var protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
    var url = protocol + '//' + window.location.host + '/_trunk/ws';
    var poll_interval = 5000;
    var reload_upon_connect = () => {
        window.setTimeout(
            () => {
                // when we successfully reconnect, we'll force a
                // reload (since we presumably lost connection to
                // trunk due to it being killed, so it will have
                // rebuilt on restart)
                var ws = new WebSocket(url);
                ws.onopen = () => window.location.reload();
                ws.onclose = reload_upon_connect;
            },
            poll_interval);
    };

    var ws = new WebSocket(url);
    ws.onmessage = (ev) => {
        const msg = JSON.parse(ev.data);
        if (msg.reload) {
            window.location.reload();
        }
    };
    ws.onclose = reload_upon_connect;
})()
</script></body></html>